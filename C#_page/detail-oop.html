<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP - Objektorientierung - Detailansicht</title>
    <link rel="stylesheet" href="unified-style.css">
</head>
<body class="detail-page">
    <div class="container">
        <a href="index.html" class="back-button">â† ZurÃ¼ck zur Ãœbersicht</a>

        <div class="page-header">
            <h1>ğŸ¯ Objektorientierung (OOP)</h1>
            <p>Kapselung, Vererbung, Polymorphie und Abstraktion verstehen</p>
        </div>

        <div class="content-section">
            <h2>ğŸ§© Was ist OOP?</h2>
            <p>
                Objektorientierte Programmierung (OOP) ist ein Programmierparadigma, bei dem Code in <strong>Klassen</strong> und <strong>Objekte</strong> organisiert wird. Statt langen Prozeduren schreibt man BauplÃ¤ne (Klassen), aus denen man Instanzen (Objekte) erstellt.
            </p>
            <div class="example-box">
                <h4>ğŸ—ï¸ Analogie: Bauplan und HÃ¤user</h4>
                <p>
                    Eine <strong>Klasse</strong> ist wie ein Bauplan fÃ¼r ein Haus â€“ er beschreibt, wie das Haus aussieht und was es kann.<br>
                    Ein <strong>Objekt</strong> ist ein konkretes, tatsÃ¤chliches Haus, das nach diesem Bauplan gebaut wurde.<br>
                    Aus einem Bauplan kannst du <strong>viele HÃ¤user</strong> bauen â€“ jedes ist ein eigenes Objekt!
                </p>
            </div>
            <div class="info-box">
                <div>
                    <strong>Die 4 SÃ¤ulen der OOP:</strong> Kapselung Â· Vererbung Â· Polymorphie Â· Abstraktion
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>ğŸ”¨ Klassen und Objekte</h2>

            <pre><span class="c">// Klasse definieren = Bauplan erstellen</span>
<span class="k">public class</span> <span class="t">Auto</span>
{
    <span class="c">// Eigenschaften (Properties) - Was hat ein Auto?</span>
    <span class="k">public string</span> Marke { <span class="k">get; set;</span> }
    <span class="k">public string</span> Farbe { <span class="k">get; set;</span> }
    <span class="k">public int</span> Baujahr { <span class="k">get; set;</span> }
    <span class="k">private int</span> _kilometerstand = 0;  <span class="c">// Privates Feld</span>

    <span class="c">// Konstruktor - Wird beim Erstellen aufgerufen</span>
    <span class="k">public</span> Auto(<span class="t">string</span> marke, <span class="t">string</span> farbe, <span class="t">int</span> baujahr)
    {
        Marke = marke;
        Farbe = farbe;
        Baujahr = baujahr;
    }

    <span class="c">// Methoden - Was kann ein Auto?</span>
    <span class="k">public void</span> Fahren(<span class="t">int</span> km)
    {
        _kilometerstand += km;
        Console.WriteLine(<span class="s">$"Gefahren! Kilometerstand: {_kilometerstand}"</span>);
    }

    <span class="k">public string</span> BeschreibeDich() =>
        <span class="s">$"{Farbe} {Marke} ({Baujahr}), {_kilometerstand} km"</span>;
}

<span class="c">// Objekte erstellen (Instanzen des Bauplans)</span>
<span class="t">Auto</span> meinAuto = <span class="k">new</span> <span class="t">Auto</span>(<span class="s">"BMW"</span>, <span class="s">"Blau"</span>, 2020);
<span class="t">Auto</span> nochEinsAuto = <span class="k">new</span> <span class="t">Auto</span>(<span class="s">"VW"</span>, <span class="s">"Rot"</span>, 2018);

meinAuto.Fahren(150);
Console.WriteLine(meinAuto.BeschreibeDich());</pre>

            <h3>ğŸ”‘ Zugriffsmodifizierer</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Modifizierer</th>
                        <th>Sichtbar fÃ¼r</th>
                        <th>Wann nutzen?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>public</code></td>
                        <td>Alle</td>
                        <td>API-Methoden, Properties</td>
                    </tr>
                    <tr>
                        <td><code>private</code></td>
                        <td>Nur diese Klasse</td>
                        <td>Interne Felder, Hilfsmethoden</td>
                    </tr>
                    <tr>
                        <td><code>protected</code></td>
                        <td>Diese Klasse + Unterklassen</td>
                        <td>Vererbungs-Szenarien</td>
                    </tr>
                    <tr>
                        <td><code>internal</code></td>
                        <td>Nur dieses Projekt</td>
                        <td>Projektinterne Klassen</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="content-section">
            <h2>ğŸ”’ SÃ¤ule 1: Kapselung</h2>
            <p>
                Kapselung bedeutet, interne Details einer Klasse zu <strong>verstecken</strong> und nur kontrolliert nach auÃŸen zugÃ¤nglich zu machen. So schÃ¼tzt du die IntegritÃ¤t deiner Daten.
            </p>

            <pre><span class="k">public class</span> <span class="t">Bankkonto</span>
{
    <span class="c">// private: Von auÃŸen nicht direkt Ã¤nderbar!</span>
    <span class="k">private decimal</span> _kontostand = 0;

    <span class="c">// public: Getter erlaubt Lesen, aber kein direktes Setzen</span>
    <span class="k">public decimal</span> Kontostand => _kontostand;

    <span class="c">// Kontrollierte Methoden fÃ¼r Ã„nderungen</span>
    <span class="k">public bool</span> Einzahlen(<span class="t">decimal</span> betrag)
    {
        <span class="k">if</span> (betrag <= 0) <span class="k">return false</span>;  <span class="c">// Validierung!</span>
        _kontostand += betrag;
        <span class="k">return true</span>;
    }

    <span class="k">public bool</span> Abheben(<span class="t">decimal</span> betrag)
    {
        <span class="k">if</span> (betrag > _kontostand) <span class="k">return false</span>;  <span class="c">// Schutz!</span>
        _kontostand -= betrag;
        <span class="k">return true</span>;
    }
}

<span class="t">Bankkonto</span> konto = <span class="k">new</span> <span class="t">Bankkonto</span>();
konto.Einzahlen(500);
<span class="c">// konto._kontostand = 1000;  âŒ Fehler! Private Feld</span>
Console.WriteLine(konto.Kontostand);  <span class="c">// âœ… 500</span></pre>
        </div>

        <div class="content-section">
            <h2>ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ SÃ¤ule 2: Vererbung</h2>
            <p>
                Vererbung erlaubt es, eine neue Klasse auf Basis einer bestehenden zu erstellen. Die <strong>Unterklasse</strong> erbt alle Eigenschaften und Methoden der <strong>Basisklasse</strong>.
            </p>

            <pre><span class="c">// Basisklasse (Parent)</span>
<span class="k">public class</span> <span class="t">Tier</span>
{
    <span class="k">public string</span> Name { <span class="k">get; set;</span> }
    <span class="k">public int</span> Alter { <span class="k">get; set;</span> }

    <span class="k">public virtual void</span> MachGerÃ¤usch()  <span class="c">// virtual = Ã¼berschreibbar</span>
    {
        Console.WriteLine(<span class="s">"..."</span>);
    }

    <span class="k">public void</span> Essen() => Console.WriteLine(<span class="s">$"{Name} frisst"</span>);
}

<span class="c">// Unterklasse erbt von Tier</span>
<span class="k">public class</span> <span class="t">Hund</span> : <span class="t">Tier</span>
{
    <span class="k">public string</span> Rasse { <span class="k">get; set;</span> }

    <span class="c">// override = Ã¼berschreibt die Basisklassen-Methode</span>
    <span class="k">public override void</span> MachGerÃ¤usch()
    {
        Console.WriteLine(<span class="s">"Wuff!"</span>);
    }

    <span class="k">public void</span> Apportieren() => Console.WriteLine(<span class="s">"Holt den Ball!"</span>);
}

<span class="k">public class</span> <span class="t">Katze</span> : <span class="t">Tier</span>
{
    <span class="k">public override void</span> MachGerÃ¤usch() => Console.WriteLine(<span class="s">"Miau!"</span>);
}

<span class="c">// Verwendung</span>
<span class="t">Hund</span> bello = <span class="k">new</span> <span class="t">Hund</span>() { Name = <span class="s">"Bello"</span>, Alter = 3, Rasse = <span class="s">"Labrador"</span> };
bello.Essen();           <span class="c">// Geerbt von Tier: "Bello frisst"</span>
bello.MachGerÃ¤usch();   <span class="c">// Ãœberschrieben: "Wuff!"</span>
bello.Apportieren();    <span class="c">// Nur Hund hat das: "Holt den Ball!"</span></pre>

            <div class="warning-box">
                <div>
                    <strong>âš ï¸ Einfachvererbung:</strong> In C# kann eine Klasse nur von <strong>einer einzigen</strong> Basisklasse erben. Mehrere Interfaces sind aber erlaubt!
                </div>
            </div>

            <h3>ğŸ”‘ base â€“ Zugriff auf Basisklasse</h3>
            <pre><span class="k">public class</span> <span class="t">ElektrischerHund</span> : <span class="t">Hund</span>
{
    <span class="k">public int</span> Akkustand { <span class="k">get; set;</span> }

    <span class="k">public override void</span> MachGerÃ¤usch()
    {
        <span class="c">// base ruft die Methode der Elternklasse auf</span>
        <span class="k">base</span>.MachGerÃ¤usch();  <span class="c">// "Wuff!" von Hund</span>
        Console.WriteLine(<span class="s">"*BEEP*"</span>);
    }
}</pre>
        </div>

        <div class="content-section">
            <h2>ğŸ­ SÃ¤ule 3: Polymorphie</h2>
            <p>
                Polymorphie bedeutet "viele Formen". Objekte unterschiedlicher Klassen kÃ¶nnen Ã¼ber einen gemeinsamen Typ verwendet werden â€“ jedes verhÃ¤lt sich dann auf seine eigene Art.
            </p>

            <pre><span class="t">Tier</span>[] tiere = 
{
    <span class="k">new</span> <span class="t">Hund</span>() { Name = <span class="s">"Bello"</span> },
    <span class="k">new</span> <span class="t">Katze</span>() { Name = <span class="s">"Mieze"</span> },
    <span class="k">new</span> <span class="t">Hund</span>() { Name = <span class="s">"Rex"</span> }
};

<span class="c">// Jedes Tier macht sein eigenes GerÃ¤usch!</span>
<span class="k">foreach</span> (<span class="t">Tier</span> tier <span class="k">in</span> tiere)
{
    Console.Write(<span class="s">$"{tier.Name}: "</span>);
    tier.MachGerÃ¤usch();  <span class="c">// Polymorphie in Aktion!</span>
}
<span class="c">// Bello: Wuff!
// Mieze: Miau!
// Rex: Wuff!</span></pre>
        </div>

        <div class="content-section">
            <h2>ğŸ“‹ Interfaces â€“ VertrÃ¤ge definieren</h2>
            <p>
                Ein <strong>Interface</strong> definiert einen Vertrag: Es sagt <em>was</em> eine Klasse kÃ¶nnen muss, aber nicht <em>wie</em> sie es macht.
            </p>

            <pre><span class="c">// Interface = Vertrag</span>
<span class="k">public interface</span> <span class="t">IFlyable</span>
{
    <span class="k">void</span> Fliegen();              <span class="c">// Muss implementiert werden</span>
    <span class="t">int</span> MaxHÃ¶he { <span class="k">get;</span> }       <span class="c">// Property-Vertrag</span>
}

<span class="k">public interface</span> <span class="t">ISchwimmbar</span>
{
    <span class="k">void</span> Schwimmen();
}

<span class="c">// Klasse implementiert mehrere Interfaces!</span>
<span class="k">public class</span> <span class="t">Ente</span> : <span class="t">Tier</span>, <span class="t">IFlyable</span>, <span class="t">ISchwimmbar</span>
{
    <span class="k">public int</span> MaxHÃ¶he => 500;  <span class="c">// Interface-Property</span>

    <span class="k">public void</span> Fliegen() => Console.WriteLine(<span class="s">"Quak-quak-flatter!"</span>);
    <span class="k">public void</span> Schwimmen() => Console.WriteLine(<span class="s">"Planschen!"</span>);

    <span class="k">public override void</span> MachGerÃ¤usch() => Console.WriteLine(<span class="s">"Quak!"</span>);
}

<span class="c">// Interface als Typ verwenden</span>
<span class="t">IFlyable</span>[] fliegendeObjekte = 
{
    <span class="k">new</span> <span class="t">Ente</span>(),
    <span class="c">// new Flugzeug(), usw.</span>
};
<span class="k">foreach</span> (<span class="k">var</span> obj <span class="k">in</span> fliegendeObjekte) obj.Fliegen();</pre>
        </div>

        <div class="content-section">
            <h2>ğŸ“ Zusammenfassung</h2>
            <div class="success-box">
                <div>
                    <strong>âœ… Was du gelernt hast:</strong>
                    <ul>
                        <li><strong>Klasse</strong> = Bauplan, <strong>Objekt</strong> = konkrete Instanz</li>
                        <li><strong>Kapselung:</strong> private Felder, public Methoden fÃ¼r kontrollierten Zugriff</li>
                        <li><strong>Vererbung:</strong> Unterklassen erben von Basisklasse, <code>override</code> fÃ¼r Anpassung</li>
                        <li><strong>Polymorphie:</strong> verschiedene Objekte, gleiche Methode, unterschiedliches Verhalten</li>
                        <li><strong>Interface:</strong> Vertrag â€“ was muss die Klasse kÃ¶nnen? Mehrere erlaubt!</li>
                    </ul>
                </div>
            </div>
            <div class="info-box">
                <div>
                    <strong>â¡ï¸ NÃ¤chster Schritt:</strong>
                    <p>Lerne jetzt <strong>"Generics & LINQ"</strong> â€“ damit kannst du typsicheren Code fÃ¼r beliebige Typen schreiben und Daten elegant abfragen!</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
